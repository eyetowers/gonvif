// Code generated by gowsdl DO NOT EDIT.

package wsdl

import (
	"context"
	"encoding/xml"
	"time"

	wsa "github.com/eyetowers/gonvif/pkg/generated/onvif/www_w3_org/2005/08/addressing"
	wsnt "github.com/eyetowers/gonvif/pkg/generated/onvif/docs_oasisopen_org/wsn/b2"
	wstop "github.com/eyetowers/gonvif/pkg/generated/onvif/docs_oasisopen_org/wsn/t1"

	"github.com/eyetowers/gowsdl/soap"
)

// against "unused imports"
var _ time.Time
var _ xml.Name
var _ context.Context
var _ soap.SOAPEnvelope

type EventBrokerProtocol string
type EmptyString string

const (
	EventBrokerProtocolMqtt EventBrokerProtocol = "mqtt"

	EventBrokerProtocolMqtts EventBrokerProtocol = "mqtts"

	EventBrokerProtocolWs EventBrokerProtocol = "ws"

	EventBrokerProtocolWss EventBrokerProtocol = "wss"
)

type ConnectionStatus string

const (
	ConnectionStatusOffline ConnectionStatus = "Offline"

	ConnectionStatusConnecting ConnectionStatus = "Connecting"

	ConnectionStatusConnected ConnectionStatus = "Connected"
)

type GetServiceCapabilities struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/events/wsdl GetServiceCapabilities" json:"-"`
}

type GetServiceCapabilitiesResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/events/wsdl GetServiceCapabilitiesResponse" json:"-"`

	// The capabilities for the event service is returned in the Capabilities element.
	Capabilities *Capabilities `xml:"Capabilities,omitempty" json:"Capabilities,omitempty"`
}

type CreatePullPointSubscription struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/events/wsdl CreatePullPointSubscription" json:"-"`

	// Optional XPATH expression to select specific topics.
	Filter *wsnt.FilterType `xml:"Filter,omitempty" json:"Filter,omitempty"`

	// Initial termination time.
	InitialTerminationTime *wsnt.AbsoluteOrRelativeTimeType `xml:"InitialTerminationTime,omitempty" json:"InitialTerminationTime,omitempty"`

	SubscriptionPolicy struct {
	} `xml:"SubscriptionPolicy,omitempty" json:"SubscriptionPolicy,omitempty"`

	Items []string `xml:",any" json:"items,omitempty"`
}

type CreatePullPointSubscriptionResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/events/wsdl CreatePullPointSubscriptionResponse" json:"-"`

	// Endpoint reference of the subscription to be used for pulling the messages.
	SubscriptionReference *wsa.EndpointReferenceType `xml:"SubscriptionReference,omitempty" json:"SubscriptionReference,omitempty"`

	CurrentTime *wsnt.CurrentTime `xml:"CurrentTime,omitempty" json:"CurrentTime,omitempty"`

	TerminationTime *wsnt.TerminationTime `xml:"TerminationTime,omitempty" json:"TerminationTime,omitempty"`

	Items []string `xml:",any" json:"items,omitempty"`
}

type PullMessages struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/events/wsdl PullMessages" json:"-"`

	// Maximum time to block until this method returns.
	Timeout string `xml:"Timeout,omitempty" json:"Timeout,omitempty"`

	// Upper limit for the number of messages to return at once. A server implementation may decide to return less messages.
	MessageLimit int32 `xml:"MessageLimit,omitempty" json:"MessageLimit,omitempty"`

	Items []string `xml:",any" json:"items,omitempty"`
}

type PullMessagesResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/events/wsdl PullMessagesResponse" json:"-"`

	// The date and time when the messages have been delivered by the web server to the client.
	CurrentTime soap.XSDDateTime `xml:"CurrentTime,omitempty" json:"CurrentTime,omitempty"`

	// Date time when the PullPoint will be shut down without further pull requests.
	TerminationTime soap.XSDDateTime `xml:"TerminationTime,omitempty" json:"TerminationTime,omitempty"`

	NotificationMessage []*wsnt.NotificationMessage `xml:"NotificationMessage,omitempty" json:"NotificationMessage,omitempty"`
}

type PullMessagesFaultResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/events/wsdl PullMessagesFaultResponse" json:"-"`

	// Maximum timeout supported by the device.
	MaxTimeout string `xml:"MaxTimeout,omitempty" json:"MaxTimeout,omitempty"`

	// Maximum message limit supported by the device.
	MaxMessageLimit int32 `xml:"MaxMessageLimit,omitempty" json:"MaxMessageLimit,omitempty"`

	Items []string `xml:",any" json:"items,omitempty"`
}

type Seek struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/events/wsdl Seek" json:"-"`

	// The date and time to match against stored messages.
	UtcTime soap.XSDDateTime `xml:"UtcTime,omitempty" json:"UtcTime,omitempty"`

	// Reverse the pull direction of PullMessages.
	Reverse bool `xml:"Reverse,omitempty" json:"Reverse,omitempty"`

	Items []string `xml:",any" json:"items,omitempty"`
}

type SeekResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/events/wsdl SeekResponse" json:"-"`
}

type SetSynchronizationPoint struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/events/wsdl SetSynchronizationPoint" json:"-"`
}

type SetSynchronizationPointResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/events/wsdl SetSynchronizationPointResponse" json:"-"`
}

type GetEventProperties struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/events/wsdl GetEventProperties" json:"-"`
}

type GetEventPropertiesResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/events/wsdl GetEventPropertiesResponse" json:"-"`

	// List of topic namespaces supported.
	TopicNamespaceLocation []string `xml:"TopicNamespaceLocation,omitempty" json:"TopicNamespaceLocation,omitempty"`

	FixedTopicSet *wsnt.FixedTopicSet `xml:"FixedTopicSet,omitempty" json:"FixedTopicSet,omitempty"`

	TopicSet *wstop.TopicSet `xml:"TopicSet,omitempty" json:"TopicSet,omitempty"`

	TopicExpressionDialect []*wsnt.TopicExpressionDialect `xml:"TopicExpressionDialect,omitempty" json:"TopicExpressionDialect,omitempty"`

	//
	// Defines the XPath function set supported for message content filtering.
	// The following MessageContentFilterDialects should be returned if a device supports the message content filtering:
	//
	// A device that does not support any MessageContentFilterDialect returns a single empty url.
	//
	MessageContentFilterDialect []string `xml:"MessageContentFilterDialect,omitempty" json:"MessageContentFilterDialect,omitempty"`

	//
	// Optional ProducerPropertiesDialects. Refer to  for advanced filtering.
	ProducerPropertiesFilterDialect []string `xml:"ProducerPropertiesFilterDialect,omitempty" json:"ProducerPropertiesFilterDialect,omitempty"`

	//
	// The Message Content Description Language allows referencing
	// of vendor-specific types. In order to ease the integration of such types into a client application,
	// the GetEventPropertiesResponse shall list all URI locations to schema files whose types are
	// used in the description of notifications, with MessageContentSchemaLocation elements.
	// This list shall at least contain the URI of the ONVIF schema file.
	MessageContentSchemaLocation []string `xml:"MessageContentSchemaLocation,omitempty" json:"MessageContentSchemaLocation,omitempty"`

	Items []string `xml:",any" json:"items,omitempty"`
}

type AddEventBroker struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/events/wsdl AddEventBroker" json:"-"`

	EventBroker *EventBrokerConfig `xml:"EventBroker,omitempty" json:"EventBroker,omitempty"`
}

type AddEventBrokerResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/events/wsdl AddEventBrokerResponse" json:"-"`
}

type DeleteEventBroker struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/events/wsdl DeleteEventBroker" json:"-"`

	Address string `xml:"Address,omitempty" json:"Address,omitempty"`
}

type DeleteEventBrokerResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/events/wsdl DeleteEventBrokerResponse" json:"-"`
}

type GetEventBrokers struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/events/wsdl GetEventBrokers" json:"-"`

	Address string `xml:"Address,omitempty" json:"Address,omitempty"`
}

type GetEventBrokersResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/events/wsdl GetEventBrokersResponse" json:"-"`

	EventBroker []*EventBrokerConfig `xml:"EventBroker,omitempty" json:"EventBroker,omitempty"`
}

type Capabilities struct {
	Items []string `xml:",any" json:"items,omitempty"`

	// Indicates that the WS Subscription policy is supported.

	WSSubscriptionPolicySupport bool `xml:"WSSubscriptionPolicySupport,attr,omitempty" json:"WSSubscriptionPolicySupport,omitempty"`

	// Indicates that the WS Pull Point is supported.

	WSPullPointSupport bool `xml:"WSPullPointSupport,attr,omitempty" json:"WSPullPointSupport,omitempty"`

	// Indicates that the WS Pausable Subscription Manager Interface is supported.

	WSPausableSubscriptionManagerInterfaceSupport bool `xml:"WSPausableSubscriptionManagerInterfaceSupport,attr,omitempty" json:"WSPausableSubscriptionManagerInterfaceSupport,omitempty"`

	// Maximum number of supported notification producers as defined by WS-BaseNotification.

	MaxNotificationProducers int32 `xml:"MaxNotificationProducers,attr,omitempty" json:"MaxNotificationProducers,omitempty"`

	// Maximum supported number of notification pull points.

	MaxPullPoints int32 `xml:"MaxPullPoints,attr,omitempty" json:"MaxPullPoints,omitempty"`

	// Indication if the device supports persistent notification storage.

	PersistentNotificationStorage bool `xml:"PersistentNotificationStorage,attr,omitempty" json:"PersistentNotificationStorage,omitempty"`

	// A space separated list of supported event broker protocols as defined by the tev:EventBrokerProtocol datatype.

	EventBrokerProtocols string `xml:"EventBrokerProtocols,attr,omitempty" json:"EventBrokerProtocols,omitempty"`

	// Maxiumum number of event broker configurations that can be added to the device.

	MaxEventBrokers int32 `xml:"MaxEventBrokers,attr,omitempty" json:"MaxEventBrokers,omitempty"`

	// Indicates that metadata streaming over MQTT is supported

	MetadataOverMQTT bool `xml:"MetadataOverMQTT,attr,omitempty" json:"MetadataOverMQTT,omitempty"`
}

type EventBrokerConfig struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver10/events/wsdl EventBroker" json:"-"`

	// Event broker address in the format "scheme://host:port[/resource]". The supported schemes shall be returned by the EventBrokerProtocols capability. The resource part of the URL is only valid when using websocket. The Address must be unique.
	Address string `xml:"Address,omitempty" json:"Address,omitempty"`

	// Prefix that will be prepended to all topics before they are published. This is used to make published topics unique for each device. TopicPrefix is not allowed to be empty.
	TopicPrefix string `xml:"TopicPrefix,omitempty" json:"TopicPrefix,omitempty"`

	// User name for the event broker.
	UserName string `xml:"UserName,omitempty" json:"UserName,omitempty"`

	// Password for the event broker. Password shall not be included when returned with GetEventBrokers.
	Password string `xml:"Password,omitempty" json:"Password,omitempty"`

	// Optional certificate ID in the key store pointing to a client certificate to be used for authenticating the device at the message broker.
	CertificateID string `xml:"CertificateID,omitempty" json:"CertificateID,omitempty"`

	// Concrete Topic Expression to select specific event topics to publish.
	PublishFilter *wsnt.FilterType `xml:"PublishFilter,omitempty" json:"PublishFilter,omitempty"`

	// Quality of service level to use when publishing. This defines the guarantee of delivery for a specific message: 0 = At most once, 1 = At least once, 2 = Exactly once.
	QoS int32 `xml:"QoS,omitempty" json:"QoS,omitempty"`

	// Current connection status (see tev:ConnectionStatus for possible values).
	Status string `xml:"Status,omitempty" json:"Status,omitempty"`

	// The ID of the certification path validation policy used to validate the broker certificate. In case encryption is used but no validation policy is specified, the device shall not validate the broker certificate.
	CertPathValidationPolicyID string `xml:"CertPathValidationPolicyID,omitempty" json:"CertPathValidationPolicyID,omitempty"`

	// Concrete Topic Expression to select specific metadata topics to publish.
	MetadataFilter *wsnt.FilterType `xml:"MetadataFilter,omitempty" json:"MetadataFilter,omitempty"`

	Items []string `xml:",any" json:"items,omitempty"`
}

type EventPortType interface {

	/* Returns the capabilities of the event service. The result is returned in a typed answer. */
	GetServiceCapabilities(request *GetServiceCapabilities) (*GetServiceCapabilitiesResponse, error)

	GetServiceCapabilitiesContext(ctx context.Context, request *GetServiceCapabilities) (*GetServiceCapabilitiesResponse, error)

	// Error can be either of the following types:
	//
	//   - ResourceUnknownFault
	//   - InvalidFilterFault
	//   - TopicExpressionDialectUnknownFault
	//   - InvalidTopicExpressionFault
	//   - TopicNotSupportedFault
	//   - InvalidProducerPropertiesExpressionFault
	//   - InvalidMessageContentExpressionFault
	//   - UnacceptableInitialTerminationTimeFault
	//   - UnrecognizedPolicyRequestFault
	//   - UnsupportedPolicyRequestFault
	//   - NotifyMessageNotSupportedFault
	//   - SubscribeCreationFailedFault
	/* This method returns a PullPointSubscription that can be polled using PullMessages.
	This message contains the same elements as the SubscriptionRequest of the WS-BaseNotification without the ConsumerReference.
	If no Filter is specified the pullpoint notifies all occurring events to the client.
	This method is mandatory. */
	CreatePullPointSubscription(request *CreatePullPointSubscription) (*CreatePullPointSubscriptionResponse, error)

	CreatePullPointSubscriptionContext(ctx context.Context, request *CreatePullPointSubscription) (*CreatePullPointSubscriptionResponse, error)

	/* The WS-BaseNotification specification defines a set of OPTIONAL WS-ResouceProperties.
	This specification does not require the implementation of the WS-ResourceProperty interface.
	Instead, the subsequent direct interface shall be implemented by an ONVIF compliant device
	in order to provide information about the FilterDialects, Schema files and topics supported by
	the device. */
	GetEventProperties(request *GetEventProperties) (*GetEventPropertiesResponse, error)

	GetEventPropertiesContext(ctx context.Context, request *GetEventProperties) (*GetEventPropertiesResponse, error)

	/* The AddEventBroker command allows an ONVIF client to add an event broker configuration to device to enable ONVIF events to be transferred to an event broker. If an existing event broker configuration already exists with the same Address, the existing configuration shall be modified. */
	AddEventBroker(request *AddEventBroker) (*AddEventBrokerResponse, error)

	AddEventBrokerContext(ctx context.Context, request *AddEventBroker) (*AddEventBrokerResponse, error)

	/* The DeleteEventBroker allows an ONVIF client to delete an event broker configuration from an ONVIF device. */
	DeleteEventBroker(request *DeleteEventBroker) (*DeleteEventBrokerResponse, error)

	DeleteEventBrokerContext(ctx context.Context, request *DeleteEventBroker) (*DeleteEventBrokerResponse, error)

	/* The GetEventBrokers command lets a client retrieve event broker configurations from the device. */
	GetEventBrokers(request *GetEventBrokers) (*GetEventBrokersResponse, error)

	GetEventBrokersContext(ctx context.Context, request *GetEventBrokers) (*GetEventBrokersResponse, error)
}

type eventPortType struct {
	client *soap.Client
}

func NewEventPortType(client *soap.Client) EventPortType {
	return &eventPortType{
		client: client,
	}
}

func (service *eventPortType) GetServiceCapabilitiesContext(ctx context.Context, request *GetServiceCapabilities) (*GetServiceCapabilitiesResponse, error) {
	response := new(GetServiceCapabilitiesResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *eventPortType) GetServiceCapabilities(request *GetServiceCapabilities) (*GetServiceCapabilitiesResponse, error) {
	return service.GetServiceCapabilitiesContext(
		context.Background(),
		request,
	)
}

func (service *eventPortType) CreatePullPointSubscriptionContext(ctx context.Context, request *CreatePullPointSubscription) (*CreatePullPointSubscriptionResponse, error) {
	response := new(CreatePullPointSubscriptionResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *eventPortType) CreatePullPointSubscription(request *CreatePullPointSubscription) (*CreatePullPointSubscriptionResponse, error) {
	return service.CreatePullPointSubscriptionContext(
		context.Background(),
		request,
	)
}

func (service *eventPortType) GetEventPropertiesContext(ctx context.Context, request *GetEventProperties) (*GetEventPropertiesResponse, error) {
	response := new(GetEventPropertiesResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *eventPortType) GetEventProperties(request *GetEventProperties) (*GetEventPropertiesResponse, error) {
	return service.GetEventPropertiesContext(
		context.Background(),
		request,
	)
}

func (service *eventPortType) AddEventBrokerContext(ctx context.Context, request *AddEventBroker) (*AddEventBrokerResponse, error) {
	response := new(AddEventBrokerResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *eventPortType) AddEventBroker(request *AddEventBroker) (*AddEventBrokerResponse, error) {
	return service.AddEventBrokerContext(
		context.Background(),
		request,
	)
}

func (service *eventPortType) DeleteEventBrokerContext(ctx context.Context, request *DeleteEventBroker) (*DeleteEventBrokerResponse, error) {
	response := new(DeleteEventBrokerResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *eventPortType) DeleteEventBroker(request *DeleteEventBroker) (*DeleteEventBrokerResponse, error) {
	return service.DeleteEventBrokerContext(
		context.Background(),
		request,
	)
}

func (service *eventPortType) GetEventBrokersContext(ctx context.Context, request *GetEventBrokers) (*GetEventBrokersResponse, error) {
	response := new(GetEventBrokersResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *eventPortType) GetEventBrokers(request *GetEventBrokers) (*GetEventBrokersResponse, error) {
	return service.GetEventBrokersContext(
		context.Background(),
		request,
	)
}

type PullPointSubscription interface {

	// Error can be either of the following types:
	//
	//   - PullMessagesFaultResponse
	/*
		This method pulls one or more messages from a PullPoint.
		The device shall provide the following PullMessages command for all SubscriptionManager
		endpoints returned by the CreatePullPointSubscription command. This method shall not wait until
		the requested number of messages is available but return as soon as at least one message is available.
		The command shall at least support a Timeout of one minute. In case a device supports retrieval of less messages
		than requested it shall return these without generating a fault. */
	PullMessages(request *PullMessages) (*PullMessagesResponse, error)

	PullMessagesContext(ctx context.Context, request *PullMessages) (*PullMessagesResponse, error)

	/*
		This method readjusts the pull pointer into the past.
		A device supporting persistent notification storage shall provide the
		following Seek command for all SubscriptionManager endpoints returned by
		the CreatePullPointSubscription command. The optional Reverse argument can
		be used to reverse the pull direction of the PullMessages command.
		The UtcTime argument will be matched against the UtcTime attribute on a
		NotificationMessage.
	*/
	Seek(request *Seek) (*SeekResponse, error)

	SeekContext(ctx context.Context, request *Seek) (*SeekResponse, error)

	/* Properties inform a client about property creation, changes and
	deletion in a uniform way. When a client wants to synchronize its properties with the
	properties of the device, it can request a synchronization point which repeats the current
	status of all properties to which a client has subscribed. The PropertyOperation of all
	produced notifications is set to “Initialized”. The Synchronization Point is
	requested directly from the SubscriptionManager which was returned in either the
	SubscriptionResponse or in the CreatePullPointSubscriptionResponse. The property update is
	transmitted via the notification transportation of the notification interface. This method is mandatory.
	*/
	SetSynchronizationPoint(request *SetSynchronizationPoint) (*SetSynchronizationPointResponse, error)

	SetSynchronizationPointContext(ctx context.Context, request *SetSynchronizationPoint) (*SetSynchronizationPointResponse, error)

	// Error can be either of the following types:
	//
	//   - ResourceUnknownFault
	//   - UnableToDestroySubscriptionFault
	/* The device shall provide the following Unsubscribe command for all SubscriptionManager endpoints returned by the CreatePullPointSubscription command.
	This command shall terminate the lifetime of a pull point.
	*/
	Unsubscribe(request *EmptyString) (*EmptyString, error)

	UnsubscribeContext(ctx context.Context, request *EmptyString) (*EmptyString, error)

	Renew(request *wsnt.Renew) (*wsnt.RenewResponse, error)

	RenewContext(ctx context.Context, request *wsnt.Renew) (*wsnt.RenewResponse, error)
}

type pullPointSubscription struct {
	client *soap.Client
}

func NewPullPointSubscription(client *soap.Client) PullPointSubscription {
	return &pullPointSubscription{
		client: client,
	}
}

func (service *pullPointSubscription) PullMessagesContext(ctx context.Context, request *PullMessages) (*PullMessagesResponse, error) {
	response := new(PullMessagesResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *pullPointSubscription) PullMessages(request *PullMessages) (*PullMessagesResponse, error) {
	return service.PullMessagesContext(
		context.Background(),
		request,
	)
}

func (service *pullPointSubscription) SeekContext(ctx context.Context, request *Seek) (*SeekResponse, error) {
	response := new(SeekResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *pullPointSubscription) Seek(request *Seek) (*SeekResponse, error) {
	return service.SeekContext(
		context.Background(),
		request,
	)
}

func (service *pullPointSubscription) SetSynchronizationPointContext(ctx context.Context, request *SetSynchronizationPoint) (*SetSynchronizationPointResponse, error) {
	response := new(SetSynchronizationPointResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *pullPointSubscription) SetSynchronizationPoint(request *SetSynchronizationPoint) (*SetSynchronizationPointResponse, error) {
	return service.SetSynchronizationPointContext(
		context.Background(),
		request,
	)
}

func (service *pullPointSubscription) UnsubscribeContext(ctx context.Context, request *EmptyString) (*EmptyString, error) {
	response := new(EmptyString)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *pullPointSubscription) Unsubscribe(request *EmptyString) (*EmptyString, error) {
	return service.UnsubscribeContext(
		context.Background(),
		request,
	)
}

func (service *pullPointSubscription) RenewContext(ctx context.Context, request *wsnt.Renew) (*wsnt.RenewResponse, error) {
	response := new(wsnt.RenewResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *pullPointSubscription) Renew(request *wsnt.Renew) (*wsnt.RenewResponse, error) {
	return service.RenewContext(
		context.Background(),
		request,
	)
}
