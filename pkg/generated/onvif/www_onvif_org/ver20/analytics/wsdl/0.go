// Code generated by gowsdl DO NOT EDIT.

package wsdl

import (
	"context"
	"encoding/xml"
	"github.com/hooklift/gowsdl/soap"
	"time"

	tt "github.com/eyetowers/gonvif/pkg/generated/onvif/www_onvif_org/ver10/schema"
	tt2 "github.com/eyetowers/gonvif/pkg/generated/onvif/www_onvif_org/ver20/schema"
)

// against "unused imports"
var _ time.Time
var _ xml.Name
var _ context.Context
var _ soap.SOAPEnvelope

type GetServiceCapabilities struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver20/analytics/wsdl GetServiceCapabilities" json:"-"`
}

type GetServiceCapabilitiesResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver20/analytics/wsdl GetServiceCapabilitiesResponse" json:"-"`

	// The capabilities for the analytics service is returned in the Capabilities element.
	Capabilities *Capabilities `xml:"Capabilities,omitempty" json:"Capabilities,omitempty"`
}

type GetSupportedRules struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver20/analytics/wsdl GetSupportedRules" json:"-"`

	//
	// References an existing Video Analytics configuration. The list of available tokens can be obtained
	// via the Media service GetVideoAnalyticsConfigurations method.
	//
	ConfigurationToken *tt.ReferenceToken `xml:"ConfigurationToken,omitempty" json:"ConfigurationToken,omitempty"`
}

type GetSupportedRulesResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver20/analytics/wsdl GetSupportedRulesResponse" json:"-"`

	SupportedRules *tt.SupportedRules `xml:"SupportedRules,omitempty" json:"SupportedRules,omitempty"`
}

type CreateRules struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver20/analytics/wsdl CreateRules" json:"-"`

	// Reference to an existing VideoAnalyticsConfiguration.
	ConfigurationToken *tt.ReferenceToken `xml:"ConfigurationToken,omitempty" json:"ConfigurationToken,omitempty"`

	Rule []*tt.Config `xml:"Rule,omitempty" json:"Rule,omitempty"`
}

type CreateRulesResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver20/analytics/wsdl CreateRulesResponse" json:"-"`
}

type DeleteRules struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver20/analytics/wsdl DeleteRules" json:"-"`

	// Reference to an existing VideoAnalyticsConfiguration.
	ConfigurationToken *tt.ReferenceToken `xml:"ConfigurationToken,omitempty" json:"ConfigurationToken,omitempty"`

	// References the specific rule to be deleted (e.g. "MyLineDetector").
	RuleName []string `xml:"RuleName,omitempty" json:"RuleName,omitempty"`
}

type DeleteRulesResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver20/analytics/wsdl DeleteRulesResponse" json:"-"`
}

type ModifyRules struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver20/analytics/wsdl ModifyRules" json:"-"`

	// Reference to an existing VideoAnalyticsConfiguration.
	ConfigurationToken *tt.ReferenceToken `xml:"ConfigurationToken,omitempty" json:"ConfigurationToken,omitempty"`

	Rule []*tt.Config `xml:"Rule,omitempty" json:"Rule,omitempty"`
}

type ModifyRulesResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver20/analytics/wsdl ModifyRulesResponse" json:"-"`
}

type GetRules struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver20/analytics/wsdl GetRules" json:"-"`

	// Reference to an existing VideoAnalyticsConfiguration.
	ConfigurationToken *tt.ReferenceToken `xml:"ConfigurationToken,omitempty" json:"ConfigurationToken,omitempty"`
}

type GetRulesResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver20/analytics/wsdl GetRulesResponse" json:"-"`

	Rule []*tt.Config `xml:"Rule,omitempty" json:"Rule,omitempty"`
}

type GetRuleOptions struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver20/analytics/wsdl GetRuleOptions" json:"-"`

	// Reference to an SupportedRule Type returned from GetSupportedRules.
	RuleType string `xml:"RuleType,omitempty" json:"RuleType,omitempty"`

	// Reference to an existing analytics configuration.
	ConfigurationToken *tt.ReferenceToken `xml:"ConfigurationToken,omitempty" json:"ConfigurationToken,omitempty"`
}

type GetRuleOptionsResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver20/analytics/wsdl GetRuleOptionsResponse" json:"-"`

	// A device shall provide respective ConfigOptions.RuleType for each RuleOption if the request does not specify RuleType. The response Options shall not contain any AnalyticsModule attribute.
	RuleOptions []*ConfigOptions `xml:"RuleOptions,omitempty" json:"RuleOptions,omitempty"`
}

type GetSupportedAnalyticsModules struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver20/analytics/wsdl GetSupportedAnalyticsModules" json:"-"`

	// Reference to an existing VideoAnalyticsConfiguration.
	ConfigurationToken *tt.ReferenceToken `xml:"ConfigurationToken,omitempty" json:"ConfigurationToken,omitempty"`
}

type GetSupportedAnalyticsModulesResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver20/analytics/wsdl GetSupportedAnalyticsModulesResponse" json:"-"`

	SupportedAnalyticsModules *tt.SupportedAnalyticsModules `xml:"SupportedAnalyticsModules,omitempty" json:"SupportedAnalyticsModules,omitempty"`
}

type CreateAnalyticsModules struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver20/analytics/wsdl CreateAnalyticsModules" json:"-"`

	// Reference to an existing VideoAnalyticsConfiguration.
	ConfigurationToken *tt.ReferenceToken `xml:"ConfigurationToken,omitempty" json:"ConfigurationToken,omitempty"`

	AnalyticsModule []*tt.Config `xml:"AnalyticsModule,omitempty" json:"AnalyticsModule,omitempty"`
}

type CreateAnalyticsModulesResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver20/analytics/wsdl CreateAnalyticsModulesResponse" json:"-"`
}

type DeleteAnalyticsModules struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver20/analytics/wsdl DeleteAnalyticsModules" json:"-"`

	// Reference to an existing Video Analytics configuration.
	ConfigurationToken *tt.ReferenceToken `xml:"ConfigurationToken,omitempty" json:"ConfigurationToken,omitempty"`

	// Name of the AnalyticsModule to be deleted.
	AnalyticsModuleName []string `xml:"AnalyticsModuleName,omitempty" json:"AnalyticsModuleName,omitempty"`
}

type DeleteAnalyticsModulesResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver20/analytics/wsdl DeleteAnalyticsModulesResponse" json:"-"`
}

type ModifyAnalyticsModules struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver20/analytics/wsdl ModifyAnalyticsModules" json:"-"`

	// Reference to an existing VideoAnalyticsConfiguration.
	ConfigurationToken *tt.ReferenceToken `xml:"ConfigurationToken,omitempty" json:"ConfigurationToken,omitempty"`

	AnalyticsModule []*tt.Config `xml:"AnalyticsModule,omitempty" json:"AnalyticsModule,omitempty"`
}

type ModifyAnalyticsModulesResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver20/analytics/wsdl ModifyAnalyticsModulesResponse" json:"-"`
}

type GetAnalyticsModules struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver20/analytics/wsdl GetAnalyticsModules" json:"-"`

	// Reference to an existing VideoAnalyticsConfiguration.
	ConfigurationToken *tt.ReferenceToken `xml:"ConfigurationToken,omitempty" json:"ConfigurationToken,omitempty"`
}

type GetAnalyticsModulesResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver20/analytics/wsdl GetAnalyticsModulesResponse" json:"-"`

	AnalyticsModule []*tt.Config `xml:"AnalyticsModule,omitempty" json:"AnalyticsModule,omitempty"`
}

type GetAnalyticsModuleOptions struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver20/analytics/wsdl GetAnalyticsModuleOptions" json:"-"`

	// Reference to an SupportedAnalyticsModule Type returned from GetSupportedAnalyticsModules.
	Type string `xml:"Type,omitempty" json:"Type,omitempty"`

	// Reference to an existing AnalyticsConfiguration.
	ConfigurationToken *tt.ReferenceToken `xml:"ConfigurationToken,omitempty" json:"ConfigurationToken,omitempty"`
}

type GetAnalyticsModuleOptionsResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver20/analytics/wsdl GetAnalyticsModuleOptionsResponse" json:"-"`

	// List of options for the specified analytics module. The response Options shall not contain any RuleType attribute.
	Options []*ConfigOptions `xml:"Options,omitempty" json:"Options,omitempty"`
}

type GetSupportedMetadata struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver20/analytics/wsdl GetSupportedMetadata" json:"-"`

	// Optional reference to an AnalyticsModule Type returned from GetSupportedAnalyticsModules.
	Type string `xml:"Type,omitempty" json:"Type,omitempty"`
}

type GetSupportedMetadataResponse struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver20/analytics/wsdl GetSupportedMetadataResponse" json:"-"`

	AnalyticsModule []*MetadataInfo `xml:"AnalyticsModule,omitempty" json:"AnalyticsModule,omitempty"`
}

type Capabilities struct {
	Items []string `xml:",any" json:"items,omitempty"`

	// Indication that the device supports the rules interface and the rules syntax.

	RuleSupport bool `xml:"RuleSupport,attr,omitempty" json:"RuleSupport,omitempty"`

	// Indication that the device supports the scene analytics module interface.

	AnalyticsModuleSupport bool `xml:"AnalyticsModuleSupport,attr,omitempty" json:"AnalyticsModuleSupport,omitempty"`

	// Indication that the device produces the cell based scene description

	CellBasedSceneDescriptionSupported bool `xml:"CellBasedSceneDescriptionSupported,attr,omitempty" json:"CellBasedSceneDescriptionSupported,omitempty"`

	// Indication that the device supports the GetRuleOptions operation on the rules interface

	RuleOptionsSupported bool `xml:"RuleOptionsSupported,attr,omitempty" json:"RuleOptionsSupported,omitempty"`

	// Indication that the device supports the GetAnalyticsModuleOptions operation on the analytics interface

	AnalyticsModuleOptionsSupported bool `xml:"AnalyticsModuleOptionsSupported,attr,omitempty" json:"AnalyticsModuleOptionsSupported,omitempty"`

	// Indication that the device supports the GetSupportedMetadata operation.

	SupportedMetadata bool `xml:"SupportedMetadata,attr,omitempty" json:"SupportedMetadata,omitempty"`

	// Indication what kinds of method that the device support for sending image, acceptable values are defined in tt:ImageSendingType.

	ImageSendingType *tt.StringList `xml:"ImageSendingType,attr,omitempty" json:"ImageSendingType,omitempty"`
}

type ConfigOptions struct {
	Items []string `xml:",any" json:"items,omitempty"`

	//
	// The RuleType the ConfigOptions applies to if the Name attribute is ambiguous.
	//

	RuleType string `xml:"RuleType,attr,omitempty" json:"RuleType,omitempty"`

	//
	// The Name of the SimpleItemDescription/ElementItemDescription
	// the ConfigOptions applies to.
	//

	Name string `xml:"Name,attr,omitempty" json:"Name,omitempty"`

	//
	// Type of the Rule Options represented by a unique QName.
	// The Type defines the element contained in this structure.
	// This attribute is deprecated since its value must be identical to the embedded element.
	//

	Type string `xml:"Type,attr,omitempty" json:"Type,omitempty"`

	//
	// Optional name of the analytics module this constraint applies to. This option is only necessary in cases where different constraints for elements with the same Name exist.
	//

	AnalyticsModule string `xml:"AnalyticsModule,attr,omitempty" json:"AnalyticsModule,omitempty"`

	//
	// Minimal number of occurrences. Defaults to one.
	//

	MinOccurs int32 `xml:"minOccurs,attr,omitempty" json:"minOccurs,omitempty"`

	//
	// Maximum number of occurrences. Defaults to one.
	//

	MaxOccurs int32 `xml:"maxOccurs,attr,omitempty" json:"maxOccurs,omitempty"`
}

type MetadataInfo struct {
	XMLName xml.Name `xml:"http://www.onvif.org/ver20/analytics/wsdl AnalyticsModule" json:"-"`

	// Sample frame content starting with the tt:Frame node.
	SampleFrame *tt2.Frame `xml:"SampleFrame,omitempty" json:"SampleFrame,omitempty"`

	Items []string `xml:",any" json:"items,omitempty"`

	// Reference to an AnalyticsModule Type.

	Type string `xml:"Type,attr,omitempty" json:"Type,omitempty"`
}

type RuleEnginePort interface {

	/*
		List all rules that are supported by the given VideoAnalyticsConfiguration.
	*/
	GetSupportedRules(request *GetSupportedRules) (*GetSupportedRulesResponse, error)

	GetSupportedRulesContext(ctx context.Context, request *GetSupportedRules) (*GetSupportedRulesResponse, error)

	/*
		Add one or more rules to an existing VideoAnalyticsConfiguration.
		The available supported types can be retrieved via ,
		where the Name of the supported rule correspond to the type of an rule instance.
		Pass unique module names which can be later used as reference.
		The Parameters of the rules must match those of the corresponding description.

		Although this method is mandatory a device implementation must not support adding rules.
		Instead it can provide a fixed set of predefined configurations via the media service function
		.
	*/
	CreateRules(request *CreateRules) (*CreateRulesResponse, error)

	CreateRulesContext(ctx context.Context, request *CreateRules) (*CreateRulesResponse, error)

	/*
		Remove one or more rules from a VideoAnalyticsConfiguration.
	*/
	DeleteRules(request *DeleteRules) (*DeleteRulesResponse, error)

	DeleteRulesContext(ctx context.Context, request *DeleteRules) (*DeleteRulesResponse, error)

	/*
		List the currently assigned set of rules of a VideoAnalyticsConfiguration.
	*/
	GetRules(request *GetRules) (*GetRulesResponse, error)

	GetRulesContext(ctx context.Context, request *GetRules) (*GetRulesResponse, error)

	/*
		Return the options for the supported rules that specify an Option attribute.
	*/
	GetRuleOptions(request *GetRuleOptions) (*GetRuleOptionsResponse, error)

	GetRuleOptionsContext(ctx context.Context, request *GetRuleOptions) (*GetRuleOptionsResponse, error)

	/*
		Modify one or more rules of a VideoAnalyticsConfiguration. The rules are referenced by their names.
	*/
	ModifyRules(request *ModifyRules) (*ModifyRulesResponse, error)

	ModifyRulesContext(ctx context.Context, request *ModifyRules) (*ModifyRulesResponse, error)
}

type ruleEnginePort struct {
	client *soap.Client
}

func NewRuleEnginePort(client *soap.Client) RuleEnginePort {
	return &ruleEnginePort{
		client: client,
	}
}

func (service *ruleEnginePort) GetSupportedRulesContext(ctx context.Context, request *GetSupportedRules) (*GetSupportedRulesResponse, error) {
	response := new(GetSupportedRulesResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *ruleEnginePort) GetSupportedRules(request *GetSupportedRules) (*GetSupportedRulesResponse, error) {
	return service.GetSupportedRulesContext(
		context.Background(),
		request,
	)
}

func (service *ruleEnginePort) CreateRulesContext(ctx context.Context, request *CreateRules) (*CreateRulesResponse, error) {
	response := new(CreateRulesResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *ruleEnginePort) CreateRules(request *CreateRules) (*CreateRulesResponse, error) {
	return service.CreateRulesContext(
		context.Background(),
		request,
	)
}

func (service *ruleEnginePort) DeleteRulesContext(ctx context.Context, request *DeleteRules) (*DeleteRulesResponse, error) {
	response := new(DeleteRulesResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *ruleEnginePort) DeleteRules(request *DeleteRules) (*DeleteRulesResponse, error) {
	return service.DeleteRulesContext(
		context.Background(),
		request,
	)
}

func (service *ruleEnginePort) GetRulesContext(ctx context.Context, request *GetRules) (*GetRulesResponse, error) {
	response := new(GetRulesResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *ruleEnginePort) GetRules(request *GetRules) (*GetRulesResponse, error) {
	return service.GetRulesContext(
		context.Background(),
		request,
	)
}

func (service *ruleEnginePort) GetRuleOptionsContext(ctx context.Context, request *GetRuleOptions) (*GetRuleOptionsResponse, error) {
	response := new(GetRuleOptionsResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *ruleEnginePort) GetRuleOptions(request *GetRuleOptions) (*GetRuleOptionsResponse, error) {
	return service.GetRuleOptionsContext(
		context.Background(),
		request,
	)
}

func (service *ruleEnginePort) ModifyRulesContext(ctx context.Context, request *ModifyRules) (*ModifyRulesResponse, error) {
	response := new(ModifyRulesResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *ruleEnginePort) ModifyRules(request *ModifyRules) (*ModifyRulesResponse, error) {
	return service.ModifyRulesContext(
		context.Background(),
		request,
	)
}

type AnalyticsEnginePort interface {

	/* Returns the capabilities of the analytics service. The result is returned in a typed answer. */
	GetServiceCapabilities(request *GetServiceCapabilities) (*GetServiceCapabilitiesResponse, error)

	GetServiceCapabilitiesContext(ctx context.Context, request *GetServiceCapabilities) (*GetServiceCapabilitiesResponse, error)

	/*
		List all analytics modules that are supported by the given VideoAnalyticsConfiguration.
	*/
	GetSupportedAnalyticsModules(request *GetSupportedAnalyticsModules) (*GetSupportedAnalyticsModulesResponse, error)

	GetSupportedAnalyticsModulesContext(ctx context.Context, request *GetSupportedAnalyticsModules) (*GetSupportedAnalyticsModulesResponse, error)

	/*
		Return the options for the supported analytics modules that specify an Option attribute.
	*/
	GetAnalyticsModuleOptions(request *GetAnalyticsModuleOptions) (*GetAnalyticsModuleOptionsResponse, error)

	GetAnalyticsModuleOptionsContext(ctx context.Context, request *GetAnalyticsModuleOptions) (*GetAnalyticsModuleOptionsResponse, error)

	/*
		Add one or more analytics modules to an existing VideoAnalyticsConfiguration.
		The available supported types can be retrieved via ,
		where the Name of the supported AnalyticsModules correspond to the type of an AnalyticsModule instance.
		Pass unique module names which can be later used as reference. The Parameters of the analytics module must match those of the corresponding AnalyticsModuleDescription.

		Although this method is mandatory a device implementation may not support adding modules.
		Instead it can provide a fixed set of predefined configurations via the media service functions
		 and
		.

		The device shall ensure that a corresponding analytics engine starts operation when a client
		subscribes directly or indirectly for events produced by the analytics or rule engine or when a
		client requests the corresponding scene description stream.
		An analytics module must be attached to a Video source using the media profiles before it can be used.
		In case differing analytics configurations are attached to the same profile it is undefined which
		of the analytics module configuration becomes active if no stream is activated or multiple streams
		with different profiles are activated at the same time.
	*/
	CreateAnalyticsModules(request *CreateAnalyticsModules) (*CreateAnalyticsModulesResponse, error)

	CreateAnalyticsModulesContext(ctx context.Context, request *CreateAnalyticsModules) (*CreateAnalyticsModulesResponse, error)

	/*
		Remove one or more analytics modules from a VideoAnalyticsConfiguration referenced by their names.
	*/
	DeleteAnalyticsModules(request *DeleteAnalyticsModules) (*DeleteAnalyticsModulesResponse, error)

	DeleteAnalyticsModulesContext(ctx context.Context, request *DeleteAnalyticsModules) (*DeleteAnalyticsModulesResponse, error)

	/*
		List the currently assigned set of analytics modules of a VideoAnalyticsConfiguration.
	*/
	GetAnalyticsModules(request *GetAnalyticsModules) (*GetAnalyticsModulesResponse, error)

	GetAnalyticsModulesContext(ctx context.Context, request *GetAnalyticsModules) (*GetAnalyticsModulesResponse, error)

	/*
		Modify the settings of one or more analytics modules of a VideoAnalyticsConfiguration. The modules are referenced by their names.
		It is allowed to pass only a subset to be modified.
	*/
	ModifyAnalyticsModules(request *ModifyAnalyticsModules) (*ModifyAnalyticsModulesResponse, error)

	ModifyAnalyticsModulesContext(ctx context.Context, request *ModifyAnalyticsModules) (*ModifyAnalyticsModulesResponse, error)

	/*
		This method provides a computer readable description of the metadata that the selected analytics modules can generate.
		The type parameter allows to select a single analytics module. By default the output shall relate to all analytics modules that exist in the device.
		The response shall provide a sample XML frame.
		The sample frame shall include all potentially generated elements by the selected analytics modules.
		Note that this e.g. does not need to include all possible class type enumerations.
	*/
	GetSupportedMetadata(request *GetSupportedMetadata) (*GetSupportedMetadataResponse, error)

	GetSupportedMetadataContext(ctx context.Context, request *GetSupportedMetadata) (*GetSupportedMetadataResponse, error)
}

type analyticsEnginePort struct {
	client *soap.Client
}

func NewAnalyticsEnginePort(client *soap.Client) AnalyticsEnginePort {
	return &analyticsEnginePort{
		client: client,
	}
}

func (service *analyticsEnginePort) GetServiceCapabilitiesContext(ctx context.Context, request *GetServiceCapabilities) (*GetServiceCapabilitiesResponse, error) {
	response := new(GetServiceCapabilitiesResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *analyticsEnginePort) GetServiceCapabilities(request *GetServiceCapabilities) (*GetServiceCapabilitiesResponse, error) {
	return service.GetServiceCapabilitiesContext(
		context.Background(),
		request,
	)
}

func (service *analyticsEnginePort) GetSupportedAnalyticsModulesContext(ctx context.Context, request *GetSupportedAnalyticsModules) (*GetSupportedAnalyticsModulesResponse, error) {
	response := new(GetSupportedAnalyticsModulesResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *analyticsEnginePort) GetSupportedAnalyticsModules(request *GetSupportedAnalyticsModules) (*GetSupportedAnalyticsModulesResponse, error) {
	return service.GetSupportedAnalyticsModulesContext(
		context.Background(),
		request,
	)
}

func (service *analyticsEnginePort) GetAnalyticsModuleOptionsContext(ctx context.Context, request *GetAnalyticsModuleOptions) (*GetAnalyticsModuleOptionsResponse, error) {
	response := new(GetAnalyticsModuleOptionsResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *analyticsEnginePort) GetAnalyticsModuleOptions(request *GetAnalyticsModuleOptions) (*GetAnalyticsModuleOptionsResponse, error) {
	return service.GetAnalyticsModuleOptionsContext(
		context.Background(),
		request,
	)
}

func (service *analyticsEnginePort) CreateAnalyticsModulesContext(ctx context.Context, request *CreateAnalyticsModules) (*CreateAnalyticsModulesResponse, error) {
	response := new(CreateAnalyticsModulesResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *analyticsEnginePort) CreateAnalyticsModules(request *CreateAnalyticsModules) (*CreateAnalyticsModulesResponse, error) {
	return service.CreateAnalyticsModulesContext(
		context.Background(),
		request,
	)
}

func (service *analyticsEnginePort) DeleteAnalyticsModulesContext(ctx context.Context, request *DeleteAnalyticsModules) (*DeleteAnalyticsModulesResponse, error) {
	response := new(DeleteAnalyticsModulesResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *analyticsEnginePort) DeleteAnalyticsModules(request *DeleteAnalyticsModules) (*DeleteAnalyticsModulesResponse, error) {
	return service.DeleteAnalyticsModulesContext(
		context.Background(),
		request,
	)
}

func (service *analyticsEnginePort) GetAnalyticsModulesContext(ctx context.Context, request *GetAnalyticsModules) (*GetAnalyticsModulesResponse, error) {
	response := new(GetAnalyticsModulesResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *analyticsEnginePort) GetAnalyticsModules(request *GetAnalyticsModules) (*GetAnalyticsModulesResponse, error) {
	return service.GetAnalyticsModulesContext(
		context.Background(),
		request,
	)
}

func (service *analyticsEnginePort) ModifyAnalyticsModulesContext(ctx context.Context, request *ModifyAnalyticsModules) (*ModifyAnalyticsModulesResponse, error) {
	response := new(ModifyAnalyticsModulesResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *analyticsEnginePort) ModifyAnalyticsModules(request *ModifyAnalyticsModules) (*ModifyAnalyticsModulesResponse, error) {
	return service.ModifyAnalyticsModulesContext(
		context.Background(),
		request,
	)
}

func (service *analyticsEnginePort) GetSupportedMetadataContext(ctx context.Context, request *GetSupportedMetadata) (*GetSupportedMetadataResponse, error) {
	response := new(GetSupportedMetadataResponse)
	err := service.client.CallContext(ctx, "''", request, response)
	if err != nil {
		return nil, err
	}

	return response, nil
}

func (service *analyticsEnginePort) GetSupportedMetadata(request *GetSupportedMetadata) (*GetSupportedMetadataResponse, error) {
	return service.GetSupportedMetadataContext(
		context.Background(),
		request,
	)
}
